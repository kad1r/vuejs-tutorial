/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/vuelidate@0.7.4/src/index.js
 * 
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{h,patchChildren}from"./vval";const NIL=()=>null,buildFromKeys=(t,e,r)=>t.reduce((t,i)=>(t[r?r(i):i]=e(i),t),{});function isFunction(t){return"function"==typeof t}function isObject(t){return null!==t&&("object"==typeof t||isFunction(t))}function isPromise(t){return isObject(t)&&isFunction(t.then)}const getPath=(t,e,r,i)=>{if("function"==typeof r)return r.call(t,e,i);r=Array.isArray(r)?r:r.split(".");for(let t=0;t<r.length;t++){if(!e||"object"!=typeof e)return i;e=e[r[t]]}return void 0===e?i:e};import{withParams,pushParams,popParams}from"./params";const __isVuelidateAsyncVm="__isVuelidateAsyncVm";function makePendingAsyncVm(t,e){const r=new t({data:{p:!0,v:!1}});return e.then(t=>{r.p=!1,r.v=t},t=>{throw r.p=!1,r.v=!1,t}),r[__isVuelidateAsyncVm]=!0,r}const validationGetters={$invalid(){const t=this.proxy;return this.nestedKeys.some(t=>this.refProxy(t).$invalid)||this.ruleKeys.some(e=>!t[e])},$dirty(){return!!this.dirty||0!==this.nestedKeys.length&&this.nestedKeys.every(t=>this.refProxy(t).$dirty)},$anyDirty(){return!!this.dirty||0!==this.nestedKeys.length&&this.nestedKeys.some(t=>this.refProxy(t).$anyDirty)},$error(){return this.$dirty&&!this.$pending&&this.$invalid},$anyError(){return this.$anyDirty&&!this.$pending&&this.$invalid},$pending(){return this.ruleKeys.some(t=>this.getRef(t).$pending)||this.nestedKeys.some(t=>this.refProxy(t).$pending)},$params(){const t=this.validations;return{...buildFromKeys(this.nestedKeys,e=>t[e]&&t[e].$params||null),...buildFromKeys(this.ruleKeys,t=>this.getRef(t).$params)}}};function setDirtyRecursive(t){this.dirty=t;const e=this.proxy,r=t?"$touch":"$reset";this.nestedKeys.forEach(t=>{e[t][r]()})}const validationMethods={$touch(){setDirtyRecursive.call(this,!0)},$reset(){setDirtyRecursive.call(this,!1)},$flattenParams(){const t=this.proxy;let e=[];for(const r in this.$params)if(this.isNested(r)){const i=t[r].$flattenParams();for(let t=0;t<i.length;t++)i[t].path.unshift(r);e=e.concat(i)}else e.push({path:[],name:r,params:this.$params[r]});return e}},getterNames=Object.keys(validationGetters),methodNames=Object.keys(validationMethods);let _cachedComponent=null;const getComponent=t=>{if(_cachedComponent)return _cachedComponent;const e=t.extend({computed:{refs(){const t=this._vval;this._vval=this.children,patchChildren(t,this._vval);const e={};return this._vval.forEach(t=>{e[t.key]=t.vm}),e}},beforeCreate(){this._vval=null},beforeDestroy(){this._vval&&(patchChildren(this._vval),this._vval=null)},methods:{getModel(){return this.lazyModel?this.lazyModel(this.prop):this.model},getModelKey(t){var e=this.getModel();if(e)return e[t]},hasIter:()=>!1}}),r=e.extend({data:()=>({rule:null,lazyModel:null,model:null,lazyParentModel:null,rootModel:null}),methods:{runRule(e){const r=this.getModel();pushParams();const i=this.rule.call(this.rootModel,r,e),s=isPromise(i)?makePendingAsyncVm(t,i):i,n=popParams();return{output:s,params:n&&n.$sub?n.$sub.length>1?n:n.$sub[0]:null}}},computed:{run(){const t=this.lazyParentModel();if(Array.isArray(t)&&t.__ob__){const e=t.__ob__.dep;e.depend();const r=e.constructor.target;if(!this._indirectWatcher){const e=r.constructor;this._indirectWatcher=new e(this,()=>this.runRule(t),null,{lazy:!0})}const i=this.getModel();if(!this._indirectWatcher.dirty&&this._lastModel===i)return this._indirectWatcher.depend(),r.value;this._lastModel=i,this._indirectWatcher.evaluate(),this._indirectWatcher.depend()}else this._indirectWatcher&&(this._indirectWatcher.teardown(),this._indirectWatcher=null);return this._indirectWatcher?this._indirectWatcher.value:this.runRule(t)},$params(){return this.run.params},proxy(){const t=this.run.output;return t[__isVuelidateAsyncVm]?!!t.v:!!t},$pending(){const t=this.run.output;return!!t[__isVuelidateAsyncVm]&&t.p}},destroyed(){this._indirectWatcher&&(this._indirectWatcher.teardown(),this._indirectWatcher=null)}}),i=e.extend({data:()=>({dirty:!1,validations:null,lazyModel:null,model:null,prop:null,lazyParentModel:null,rootModel:null}),methods:{...validationMethods,refProxy(t){return this.getRef(t).proxy},getRef(t){return this.refs[t]},isNested(t){return"function"!=typeof this.validations[t]}},computed:{...validationGetters,nestedKeys(){return this.keys.filter(this.isNested)},ruleKeys(){return this.keys.filter(t=>!this.isNested(t))},keys(){return Object.keys(this.validations).filter(t=>"$params"!==t)},proxy(){const t=buildFromKeys(this.keys,t=>({enumerable:!0,configurable:!0,get:()=>this.refProxy(t)})),e=buildFromKeys(getterNames,t=>({enumerable:!0,configurable:!0,get:()=>this[t]})),r=buildFromKeys(methodNames,t=>({enumerable:!1,configurable:!0,get:()=>this[t]})),i=this.hasIter()?{$iter:{enumerable:!0,value:Object.defineProperties({},{...t})}}:{};return Object.defineProperties({},{...t,...i,$model:{enumerable:!0,get:()=>{const t=this.lazyParentModel();return null!=t?t[this.prop]:null},set:t=>{const e=this.lazyParentModel();null!=e&&(e[this.prop]=t,this.$touch())}},...e,...r})},children(){return[...this.nestedKeys.map(t=>o(this,t)),...this.ruleKeys.map(t=>l(this,t))].filter(Boolean)}}}),s=i.extend({methods:{isNested(t){return void 0!==this.validations[t]()},getRef(t){const e=this;return{get proxy(){return e.validations[t]()||!1}}}}}),n=i.extend({computed:{keys(){var t=this.getModel();return isObject(t)?Object.keys(t):[]},tracker(){const t=this.validations.$trackBy;return t?e=>`${getPath(this.rootModel,this.getModelKey(e),t)}`:t=>`${t}`},getModelLazy(){return()=>this.getModel()},children(){const t=this.validations,e=this.getModel(),r={...t};delete r.$trackBy;let s={};return this.keys.map(t=>{const n=this.tracker(t);return s.hasOwnProperty(n)?null:(s[n]=!0,h(i,n,{validations:r,prop:t,lazyParentModel:this.getModelLazy,model:e[t],rootModel:this.rootModel}))}).filter(Boolean)}},methods:{isNested:()=>!0,getRef(t){return this.refs[this.tracker(t)]},hasIter:()=>!0}}),o=(t,e)=>{if("$each"===e)return h(n,e,{validations:t.validations[e],lazyParentModel:t.lazyParentModel,prop:e,lazyModel:t.getModel,rootModel:t.rootModel});const r=t.validations[e];if(Array.isArray(r)){const i=t.rootModel,n=buildFromKeys(r,t=>(function(){return getPath(i,i.$v,t)}),t=>Array.isArray(t)?t.join("."):t);return h(s,e,{validations:n,lazyParentModel:NIL,prop:e,lazyModel:NIL,rootModel:i})}return h(i,e,{validations:r,lazyParentModel:t.getModel,prop:e,lazyModel:t.getModelKey,rootModel:t.rootModel})},l=(t,e)=>h(r,e,{rule:t.validations[e],lazyParentModel:t.lazyParentModel,lazyModel:t.getModel,rootModel:t.rootModel});return _cachedComponent={VBase:e,Validation:i}};let _cachedVue=null;function getVue(t){if(_cachedVue)return _cachedVue;let e=t.constructor;for(;e.super;)e=e.super;return _cachedVue=e,e}const validateModel=(t,e)=>{const r=getVue(t),{Validation:i,VBase:s}=getComponent(r);return new s({computed:{children(){const r="function"==typeof e?e.call(t):e;return[h(i,"$v",{validations:r,lazyParentModel:NIL,prop:"$v",model:t,rootModel:t})]}}})},validationMixin={data(){const t=this.$options.validations;return t&&(this._vuelidate=validateModel(this,t)),{}},beforeCreate(){const t=this.$options;t.validations&&(t.computed||(t.computed={}),t.computed.$v||(t.computed.$v=function(){return this._vuelidate?this._vuelidate.refs.$v.proxy:null}))},beforeDestroy(){this._vuelidate&&(this._vuelidate.$destroy(),this._vuelidate=null)}};function Vuelidate(t){t.mixin(validationMixin)}export{Vuelidate,validationMixin,withParams};export default Vuelidate;
//# sourceMappingURL=/sm/dd59ba7f62e41b68ac1e544587d293174cf1a0856dc3a6e38a3b06f07eb65447.map